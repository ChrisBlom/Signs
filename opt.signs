signatures Abstract = <Syntax,Semantic>

type_interpretations =
	[n      = <f , e -> t >
	,np     = <f , e >
	,np_to  = <f , e >
	,np_by  = <f , e >	
	,np_pl  = <f , e >		
	,s      = <f , t >
	,vp     = <f , e -> t>]


MARY :: np = 
	< "Mary"
	, (Mary :: e)
 	>
JOHN :: np = 
	< "John"
	, (John :: e)
 	>
BOB :: np = 
	< "Bob"
	, (Bob :: e)
 	>
DUNE :: np =
  < "Dune"
  , (Dune :: e)
  >
THESHIP :: np =
  < "the ship"
  , (Ship :: e)
  >    
BY :: np -> np_by = < (\x. "by" + x), id >
TO :: np -> np_to = < (\x. "to" + x), id >
WOMAN :: n = 
	< "woman"
	, (Woman' :: e -> t)
 	>
RUN :: np -> vp = 
	< (\s.s + "ran")
	, \a.\e. ( (Run' :: e -> t) e ) /\ (AG e a) 
 	>
THEWINDOW :: np = 
	< "the window"
	, (Window :: e)
 	>
THESHIP :: np = 
	< "the ship"
	, (Ship :: e)
 	>
CAKE :: n = 
	< "cake"
	, (Cake :: e -> t)
 	>
READ :: np? -> np -> vp = 
	< (\o.(\s.s + "read" + option(o,\o'.o',"")))
	, \p.\a.\e.((Read :: e -> t)(e))  /\ (AG e a) /\ option(p,\p'.(PAT e p'),exists p'.PAT e p')
  >
BLINK :: np? -> np -> vp = 
	< (\o.(\s.s + "blinks" + option(o,\o'.o',"")))
	, \p.\a.\e.((Blink :: e -> t)(e)) /\ (AG e a) /\ option( p,\p'.(PAT e p'), PAT e ( (Of :: (e->t)->e->e ) (Eyes :: e->t) a))
  >
EYES :: n = 
	< "eyes"
	, (Eyes :: e->t)
 	>
OF :: n -> np -> np = 
	< \t.\o. t + "of" + o
	, \f.\e. (Of :: (e->t)->e->e ) f e
 	>
EAT :: np? -> np -> vp = 
	< (\o.(\s.s + "eat" + option(o,\o'.o',"")))
	, \p.\a.\e.((Eat :: e -> t)(e))  /\ (AG e a) /\ option(p,\p'.(PAT e p'),exists x.PAT e x)
  >
EATtv' :: np^{exi}-> np -> vp = 
	< \o.\s.s + "eat" + o
	, \p.\a.\e.((Eat :: e -> t)(e))  /\ (AG e a) /\ (PAT e p) 
  >
EATtv :: np -> np -> vp = 
	< \o.\s.s + "eat" + o
	, \p.\a.\e.((Eat :: e -> t)(e))  /\ (AG e a) /\ (PAT e p) 
  >  
SINK :: np -> np? -> vp = 
	< \o.\s.option(s,\s'. s' + "sank" + o , o + "sank" ) 
	, \p.\a.\e.((Eat :: e -> t)(e))  /\ (PAT e p) /\ option(a,\p'.(PAT e p'), (TRUE :: t) )
  >
BUILD :: np -> np -> vp = 
	< (\o.(\s.s + "build" + o))
	, (\p.(\a.(\e.((Build :: e -> t)(e)) /\ (AG e a) /\ (PAT e p))))
 	>
LIKES :: np -> np -> vp = 
	< (\o.(\s.s + "likes" + o))
	, (\p.(\a.(\e.((Likes :: e -> t)(e)) /\ (AG e a) /\ (PAT e p))))
 	>
KISStv :: np -> np -> vp = 
	< (\o.(\s.s + "kisses" + o))
	, (\p.(\a.(\e.((Kisses :: e -> t)(e)) /\ (AG e a) /\ (PAT e p))))
 	>
KISSpl :: np -> np_pl -> vp = 
	< (\o.(\s.s + "kisses" + o))
	, (\p.(\a.(\e.((Kisses :: e -> t)(e)) /\ (AG e a) /\ (PAT e p))))
 	>
BUILDpass :: np_by? -> np -> vp = 
	< (\b.(\s.s + "was-build" + option(b,id,"")))
	, (\p.(\a.(\e.((Build :: e -> t)(e)) /\ (AG e a) /\ option(p, PAT e ,exists p'.PAT e p'))))
	>
BUILDpasstv :: np_by -> np -> vp = 
	< (\b.(\s.s + "was-build" + b))
	, (\a.(\p.(\e.((Build :: e -> t)(e)) /\ (AG e a) /\ (PAT e p))))
 	>
INTRODUCEpass :: np_by? -> np_to? -> np -> vp = 
	< \b.\t.\s.s + "was-introduced" + option(b,\b'.b',"") + option(t,\t'.t',"")
	, \a.\g.\p.\e.((Introduce :: e -> t)(e)) /\ (PAT e p) /\ option(a,\a'.(AG e a'),exists a'.AG e a') /\ option(g,\g'.(GOAL e g'),exists g'.GOAL e g')
 	>
INTROpassobl :: np_by -> np_to -> np -> vp = 
	< \b.\t.\s.s + "was-introduced" + b + t
	, \a.\g.\p.\e.((Introduce :: e -> t)(e)) /\ (PAT e p) /\ (AG e a) /\ (GOAL e g)
 	>
SHAVEtv :: np -> np -> vp = 
	< \o.\s.s + "shaves" + o
	, \p.\a.\e. ((SHAVE :: e -> t) e) /\ (AG e a) /\ (PAT e p)  
 	>
SHAVEiv :: np -> vp = 
	< \s.s + "shaves"
	, \a.\e. ((SHAVE :: e -> t) e) /\ (AG e a) /\ exists p' .(PAT e p')
 	>
SCHEREN :: np? -> np -> vp = 
	< (\o.(\s.s + "scheert" + option(o, (\o'.o'),"zich")))
	, \p.\a.\e. ((SHAVE :: e -> t) e) /\ (AG e a) /\ option(p, \p'.(PAT e p') ,(PAT e a) )
 	>
EC :: vp -> s = 
	< id
	, (\g.exists e.g(e))
 	>
BREAK :: np -> np? -> vp = 
	< (\o.(\s.option(s, (\s'.s' + "broke" + o),o + "broke")))
	, \p.\a.\e. ((Break :: e -> t)(e)) /\ option(a, \a'.(AG e a') , (TRUE :: t)) /\ (PAT e p) 
 	>
BREAKtv :: np -> np -> vp = 
	< \o.\s.s + "broke" + o
	, \p.\a.\e. ((Break :: e -> t)(e)) /\ (AG e a) /\ (PAT e p) 
 	>
GIVE :: np -> np? -> np -> vp = 
	< (\o.(\i.(\s.s + "give" + option(i,\i'.i,"") + o)))
	, (\p.(\g.(\a.(\e.((Give :: e -> t)(e)) /\ (AG e a) /\ (PAT e p) /\ option(g,\g'.GOAL e g',exists g'.GOAL e g' )))))
 	>
INTRODUCE :: np -> np? -> np -> vp = 
	< (\o.(\i.(\s.s + "introduced" + option(i,\i'.i',"") + o)))
	, (\p.(\g.(\a.(\e.((Introduce' :: e -> t)(e)) /\ (AG e a) /\ (PAT e p) /\ option(g,\g'.GOAL e g',exists g'.GOAL e g' )))))
 	>
UO :: (np -> np -> vp)->np? -> np -> vp = 
	< \v.\o.\s.  v option(o, (\o'.o'),"") s 
	, \v.\o.\s.\e.option(o,\o'.v o' s e, exists o'.v o' s e)
  >
REFL :: (np -> np -> vp)-> np? -> np -> vp = 
	< \v.\o.\s.v option(o, (\o'.o'),"") s 
	, \v.\o.\s.\e.option(o,\o'.v o', v s) s e 
  >
UOD :: (np -> np -> vp)-> np -> vp = 
	< \v.\s.  v "" s 
	, \v.\s.\e. exists o'.v o' s e 
  >
RUNBUILD :: np? -> np -> vp =
  < \o.\s.option(o,\o'. s + "build" + o',s +"run")
  , \p.option(p, (Build :: e -> e -> e -> t)   , (Run :: e -> e -> t) ) 
  >
ZICHZELF :: (np -> np -> vp) -> np -> vp =
  < \v.\s.v("zichzelf")(s)
  , \v.\a.\e.v(a)(a)(e)
  >
SELF :: (np -> np -> vp) -> np -> vp =
  < \v.\s.v("himself")(s)
  , \v.\a.\e.v(a)(a)(e)
  >
SELFO :: (np -> np -> vp) -> np? -> np -> vp =
  < \v.\o.\s. option(o,\o'.v o' s, v "" s)
  , \v.\o.\s. option(o,\o'.v o', v s ) s
  >
REFLODutch :: (np -> np -> vp) -> np? -> np -> vp =
  < \v.\o.\s. option(o,\o'.v o' s, v "zich" s)
  , \v.\o.\s. option(o,\o'.v o', v s ) s
  >
SOMETHING :: (np -> s) -> s = 
	< \f.f("something")
	, \f.exists x.f x
	>
SOMEONE :: (np -> s) -> s = 
	< \f.f("someone")
	, \f.exists x.f x
	>
EVERYONE :: (np -> s) -> s = 
	< \f.f("everyone")
	, \g.forall y.g y
	>
PASStv' :: (np -> np -> vp) -> np_by -> np -> vp = 
	< \v.\o.\s. v o (s + "was")
	, \v.\o.\s.\e. v s o e
  >
PASStv'exi :: (np -> np -> vp) -> np_by^{exi}-> np -> vp = 
	< \v.\o.\s. v o (s + "was")
	, \v.\o.\s.\e. v s o e
  >
PASStv :: (np -> np -> vp) -> np_by? -> np -> vp = 
	< \v.\o.\s. v option(o, \o'.o' ,"")  (s + "was")
	, \v.\o.\s.\e.option(o,\o'.v s o' e,exists o'.v s o' e)
  >
PASSdtv :: (np -> np? -> np -> vp) -> np_by? -> np_to? -> np -> vp = 
	< \v.\b.\t.\s. v option(b, \b'.b' ,"") t  (s + "was")
	, \v.\b.\t.\s.\e.option(b, \b'. v s t b' e , exists b'. v s t b' e)
	>
PASSdtv'exi :: (np -> np -> np -> vp) -> np_by^{exi} -> np_to^{exi} -> np -> vp = 
	< \v.\b.\t.\s. v b t (s + "was")
	, \v.\b.\t.\s.\e. v s t b e
	>
RequireObj :: (np? -> np -> vp) -> 	(np -> np -> vp) =
  < \v.\x.\y.v x^ y
  , \v.\x.\y.v x^ y
  >
DropObj :: (np? -> np -> vp) -> (np -> vp) =
  < \v.\y.v * y
  , \v.\y.v * y
  >  
READtv :: np -> np -> vp = 
	< (\o.(\s.s + "read" + o ) )
	, \p.\a.\e.((Read :: e -> t)(e))  /\ (AG e a) /\ (PAT e p) 
  >
